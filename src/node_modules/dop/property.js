var prelude = require('prelude-ls');

var helpers = require('helpers');

var types = require('oop/types').types;

var properties = require('./properties');
var Value = require('./value');



/*******************************************************************************
 * Constructor
 ******************************************************************************/

function propertySpecFactory(propertySpec) {
	var spec;

	switch (helpers.getType(propertySpec)) {
		case 'String':
			spec = {
				names: [propertySpec]
			};
			break;

		case 'Array':
			spec = {
				names: propertySpec
			};
			break;

		default:
			spec = propertySpec;
	}

	return spec;
}

var Property = function(input) {
	var spec = propertySpecFactory(input);



	// Possible names for the property -----------------------------------------

	this.names = types.Array.factory(Value.find(spec, properties['ids'].names));  // TODO Use std instead
	if (this.names.length === 0) {
		throw Error('No name given for the property');
	}



	// Build handler, from the type of the property (constructor/class) --------

	var constructor = Value.find(spec, ['ctor', 'type', 'factory', 'class', 'constructor'], true);

	if (constructor != null) {
		this.ctor = constructor;
	}



	// Default value handler ---------------------------------------------------

	var _default = Value.find(spec, ['default', 'def']);

	if (_default != null) {
		if (!prelude.isType('Function', _default)) {
			this.default = function() {
				return _default;
			}
		} else {
			this.default = _default;
		}
	}

	this.context = Value.find(spec, ['context', 'scope']) || this;



	// Post-processing handler -------------------------------------------------

	var postprocess = Value.find(spec, ['postprocess', 'postProcess', 'post', 'process']);
	if (postprocess != null) {
		this.postprocess = postprocess;
	}
	// TODO Check this is a function



	// Required flag -----------------------------------------------------------
	// If set, some methods will throw errors in case the property could not be found or guessed in an object
	var required = Value.find(spec, ['required', 'req']);
	this.required = required == true;



	// Private properties ------------------------------------------------------

	this.__input = input;
	this.__spec = spec;
}



/*******************************************************************************
 * Prototype
 ******************************************************************************/

Property.prototype = {};

Property.prototype.find = function(input) {
	var names = this.names;

	for (var i = 0, length = names.length; i < length; i++) {
		var name = names[i];
		if (input[name] !== undefined) {
			return name;
		}
	};
};

Property.prototype.build = function(value) {
	var constructor = this.ctor;

	if (constructor != null) {
		if (constructor.factory != null) {
			return constructor.factory(value);
		}

		return new constructor(value);
	}

	return value;
};

// TODO Be able to know and tell if the property has the value undefined or if it wasn't found
// FIXME Add the 'mixed' behavior
Property.prototype.extract = function(input) {
	if (input == null) {
		throw Error('Undefined input');
	}

	var value;

	// Finds the value ---------------------------------------------------------

	var name = this.find(input);

	if (name != null) {
		value = input[name];
	}



	// Skip it if explicitely null ---------------------------------------------

	var output;
	if (value === null) {
		output = {
			skipped: true,
			value: null
		};
	} else {
		output = this.process(value);
	}

	// Required check ----------------------------------------------------------

	if (this.required) {
		if (output.value == null) {
			var error = new Error('Missing required property');
			error.context = {
				input: input,
				property: this
			}
			throw error;
		}
	}



	// Return ------------------------------------------------------------------

	output.name = name;
	output.originalValue = value;

	output.input = input;
	output.property = this;

	return output;
};

Property.prototype.process = function(value) {
	var output = {};

	// Build it from its type --------------------------------------------------
	// Note: the build might fail... really? Maybe put 'default' handler above.

	value = this.build(value);



	// If value is still void, apply default & retry to build it ---------------

	if (value === undefined) {
		if (this.default != null) {
			value = this.default.call(this.context);
			value = this.build(value);
			output.default = true;
		}
	}



	// Post-process the value --------------------------------------------------

	if (this.postprocess != null) {
		value = this.postprocess.call(this.context, value);
	}



	// Return ------------------------------------------------------------------

	output.value = value;

	return output;
};



/*******************************************************************************
 * Statics
 ******************************************************************************/

// TODO return an actual instance of a property
Property.factory = propertySpecFactory;

Property.factory2 = function(input) {
	if (input instanceof Property) {
		return input;
	}

	return new Property(input);
}





/*******************************************************************************
 * Exports
 ******************************************************************************/

exports.Property = Property;
