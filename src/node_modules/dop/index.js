var prelude = require('prelude-ls');

var oop = {types: require('oop/types').types};
var helpers = require('helpers');

var Property = require('./property').Property;

var defaultProperties = require('./properties');

var valueToObject = require('./value-to-object');

var Value = require('./value');

var extractProperty = require('./extract-property').extractProperty;



/*******************************************************************************
 * Default properties specs
 ******************************************************************************/

var propertyIds = defaultProperties['ids'];


// var map = [
// 	{name: 'output', default: {}},
// 	{name: 'input'},
// 	{name: 'rules'}
// ]

// function processArguments(args, rules) {
// 	var output = {};
// 	for (var argPos = 0, length = rules.length; i < length; i++) {
// 		var arg = args[argPos];
// 		var def = rules[argPos].default;
// 		if (arg == null && def != null) {
// 			arg = def;
// 			args.
// 		}
// 	}
// }


function processProperties() {
	// Input arguments processing ----------------------------------------------

	var output;
	var input;
	var rules;
	var context;

	// --------------------------------------------- Optional arguments handling

	switch (arguments.length) {
		case 4:
			output = arguments[0];
			input = arguments[1];
			rules = arguments[2];
			context = arguments[3];
			break;
		case 3:
			throw {
				msg: 'Ambiguous arguments',
				arguments: arguments,
				stack: Error().stack
			}
			break;
		case 2:
			input = arguments[0];
			rules = arguments[1];
			break;
		default:
			throw {
				msg: 'Wrong number of arguments',
				arguments: arguments,
				stack: Error().stack
			}
	}

	// ------------------------------------------------------------------- input

	if (input == null) {
		throw {
			msg: 'No input given',
			stack: Error().stack
		}
	}

	// ------------------------------------------------------------------- rules

	if (rules == null) {
		throw {
			msg: 'No rule given',
			stack: Error().stack
		}
	} else if (!prelude.isType('Object', rules)) {
		throw {
			msg: 'Invalid given rules, expected an object',
			rules: rules,
			stack: Error().stack
		}
	}

	// ------------------------------------------------------------------ output

	if (output == null) {
		output = {};
	}

	// ----------------------------------------------------------------- context

	// Nothing to do, simply forwarded value, to be handled by called functions

	// Processing --------------------------------------------------------------

	var spec = valueToObject(
		input,
		Value.find(rules, ['factory', 'inputFactory', 'valueToObject', 'inputToSpec'])
	);

	applyProperties(
		output,
		spec,
		Value.find(rules, ['properties', 'props', 'schema', 'specs', 'spec']),
		context,
		Value.find(rules, ['acceptFreeProperties', 'acceptFree', 'free', 'extensible'])
	);

	// Return ------------------------------------------------------------------

	return output;
}



/**
 * Extracts a set of properties from an object, thanks to properties specifications, and puts the result in the output object.
 *
 * @see extractProperty
 */
function applyProperties(output, input, propertiesSpecs, context, acceptFree) {
	// Processing --------------------------------------------------------------

	var infosList = [];

	// --------------------------------------- Apply properties from given specs

	prelude.each(function(propertySpec) {
		var result = applyProperty(output, input, propertySpec, context);
		infosList.push(result.infos);
	}, propertiesSpecs);

	// -------------------------------------- Applies free properties if enabled

	if (acceptFree) {
		// Builds a list of used properties
		var usedNames = [];
		for (var i = 0, length = infosList.length; i < length; i++) {
			var infos = infosList[i];
			usedNames.push(infos.name);
		}

		// Imports free properties
		helpers.forKeyValue(function(specKey, value) {
			if (usedNames.indexOf(specKey) < 0) {
				output[specKey] = value;
			}
		}, input);
	}

	// Returns -----------------------------------------------------------------

	return output;
}



/**
 * @todo For now we consider we don't put any explicit undefined or null value in the output. This could be made configurable
 * @notDocumented
 */
function applyProperty(output, spec, propertySpec, context) {
	// Input arguments processing ----------------------------------------------

	// ------------------------------------------------------------------ output
	// -------------------------------------------------------------------- spec
	// ------------------------------------------------------------ propertySpec
	propertySpec = Property.factory(propertySpec);
	// ----------------------------------------------------------------- context

	// Processing --------------------------------------------------------------

	var infos = {};

	// Gets the explicit name for the output property
	var name = Value.find(propertySpec, ['output', 'outputName']);

	// If not explicit name was given, gets the first name of the list of possible property names
	if (name == null) {
		var names = Value.find(propertySpec, propertyIds.names);
		name = oop.types.Array.factory(names)[0]; // TODO Use std instead
	}

	if (name != null) {
		var value = extractProperty(spec, propertySpec, context, infos);
		if (value != null) {
			output[name] = value;
		}
	} else {
		throw {
			msg: 'No name found for the output property',
			spec: propertySpec
		}
	}

	// Return ------------------------------------------------------------------

	return {
		infos: infos,
		name: name,
		value: value,

		output: output
	}
}








/*******************************************************************************
 * Exports
 ******************************************************************************/

exports.processProperties = processProperties;

exports.valueToObject = valueToObject;
exports.inputToSpec = valueToObject; // alias

exports.applyProperties = applyProperties;
exports.applyProperty = applyProperty;

exports.extractProperty = extractProperty;

exports.extractValue = Value.extract;

exports.propertyIds = propertyIds;
