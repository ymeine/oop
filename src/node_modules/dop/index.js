var prelude = require('prelude-ls');

var oop = {types: require('oop/types').types};
var helpers = require('helpers');



/*******************************************************************************
* Property names
*******************************************************************************/

var propertyIds = {
	names: ['names', 'name', 'keys', 'key', 'ids', 'id']
}


// var map = [
// 	{name: 'output', default: {}},
// 	{name: 'input'},
// 	{name: 'rules'}
// ]

// function processArguments(args, rules) {
// 	var output = {};
// 	for (var argPos = 0, length = rules.length; i < length; i++) {
// 		var arg = args[argPos];
// 		var def = rules[argPos].default;
// 		if (arg == null && def != null) {
// 			arg = def;
// 			args.
// 		}
// 	}
// }


function processProperties() {
	// Input arguments processing ----------------------------------------------

	var output;
	var input;
	var rules;
	var context;

	// --------------------------------------------- Optional arguments handling

	switch (arguments.length) {
		case 4:
			output = arguments[0];
			input = arguments[1];
			rules = arguments[2];
			context = arguments[3];
			break;
		case 3:
			throw {
				msg: 'Ambiguous arguments',
				arguments: arguments,
				stack: Error().stack
			}
			break;
		case 2:
			input = arguments[0];
			rules = arguments[1];
			break;
		default:
			throw {
				msg: 'Wrong number of arguments',
				arguments: arguments,
				stack: Error().stack
			}
	}

	// ------------------------------------------------------------------- input

	if (input == null) {
		throw {
			msg: 'No input given',
			stack: Error().stack
		}
	}

	// ------------------------------------------------------------------- rules

	if (rules == null) {
		throw {
			msg: 'No rule given',
			stack: Error().stack
		}
	} else if (!prelude.isType('Object', rules)) {
		throw {
			msg: 'Invalid given rules, expected an object',
			rules: rules,
			stack: Error().stack
		}
	}

	// ------------------------------------------------------------------ output

	if (output == null) {
		output = {};
	}

	// ----------------------------------------------------------------- context

	// Nothing to do, simply forwarded value, to be handled by called functions

	// Processing --------------------------------------------------------------

	var spec = inputToSpec(
		input,
		extractValue(rules, ['inputToSpec', 'inputFactory', 'factory'])
	);

	applyProperties(
		output,
		spec,
		extractValue(rules, ['properties', 'props', 'schema', 'specs', 'spec']),
		context,
		extractValue(rules, ['acceptFreeProperties', 'acceptFree', 'free', 'extensible'])
	);

	// Return ------------------------------------------------------------------

	return output;
}

function inputToSpec(input, rules) {
	// Early termination -------------------------------------------------------

	if (prelude.isType('Object', input)) {
		return input;
	}

	// Input arguments processing ----------------------------------------------

	// ------------------------------------------------------------------- rules

	if (rules == null) {rules = {}}

	// Processing --------------------------------------------------------------

	var handler;
	helpers.forKeyValue(function(type, rule) {
		if (prelude.isType(type, input)) {
			switch (helpers.getType(rule)) {
				case 'String': // -------------------------------- property name
					handler = function(input) {
						var output = {};
						output[rule] = input;
						return output;
					}
					break;
				case 'Function': // --------------------------- function handler
					handler = rule;
					break;
				default: // -------------------------------------------- invalid
					handler = function() {return {}};
			}

			return true;
		}
	}, rules);

	// Return ------------------------------------------------------------------

	return handler(input);
}

/**
 * Extracts a set of properties from an object, thanks to properties specifications, and puts the result in the output object.
 *
 * @see extractProperty
 */
function applyProperties(output, input, propertiesSpecs, context, acceptFree) {
	// Processing --------------------------------------------------------------

	var infosList = [];

	// --------------------------------------- Apply properties from given specs

	prelude.each(function(propertySpec) {
		var result = applyProperty(output, input, propertySpec, context);
		infosList.push(result.infos);
	}, propertiesSpecs);

	// -------------------------------------- Applies free properties if enabled

	if (acceptFree) {
		// Builds a list of used properties
		var usedNames = [];
		for (var i = 0, length = infosList.length; i < length; i++) {
			var infos = infosList[i];
			usedNames.push(infos.name);
		}

		// Imports free properties
		helpers.forKeyValue(function(specKey, value) {
			if (usedNames.indexOf(specKey) < 0) {
				output[specKey] = value;
			}
		}, input);
	}

	// Returns -----------------------------------------------------------------

	return output;
}

function propertySpecFactory(propertySpec) {
	var spec;

	switch (helpers.getType(propertySpec)) {
		case 'String': spec = {names: [propertySpec]}; break;
		case 'Array': spec = {names: propertySpec}; break;
		default: spec = propertySpec;
	}

	return spec;
}

/**
 * @todo For now we consider we don't put any explicit undefined or null value in the output. This could be made configurable
 * @notDocumented
 */
function applyProperty(output, spec, propertySpec, context) {
	// Input arguments processing ----------------------------------------------

	// ------------------------------------------------------------------ output
	// -------------------------------------------------------------------- spec
	// ------------------------------------------------------------ propertySpec
	propertySpec = propertySpecFactory(propertySpec);
	// ----------------------------------------------------------------- context

	// Processing --------------------------------------------------------------

	var infos = {};

	// Gets the explicit name for the output property
	var name = extractValue(propertySpec, ['output', 'outputName']);

	// If not explicit name was given, gets the first name of the list of possible property names
	if (name == null) {
		var names = extractValue(propertySpec, propertyIds.names);
		name = oop.types.Array.factory(names)[0];
	}

	if (name != null) {
		var value = extractProperty(spec, propertySpec, context, infos);
		if (value != null) {
			output[name] = value;
		}
	} else {
		throw {
			msg: 'No name found for the output property',
			spec: propertySpec
		}
	}

	// Return ------------------------------------------------------------------

	return {
		infos: infos,
		name: name,
		value: value,

		output: output
	}
}

function extractProperty(input, propertySpec, context, infos) {
	// Input arguments processing ----------------------------------------------

	// ------------------------------------------------------------ propertySpec

	propertySpec = propertySpecFactory(propertySpec);

	// ----------------------------------------------------------------- context

	// ------------------------------------------------------------------- infos

	if (infos == null) {
		// An object that will be useless since not returned but will avoid multiple checks below
		infos = {};
	}

	// Processing --------------------------------------------------------------

	// -------------------------------------------------------------- Extraction

	var names = extractValue(propertySpec, propertyIds.names);
	names = oop.types.Array.factory(names);
	var value = extractValue(input, names, infos);
	infos.originalValue = value;

	// ----------------------------------------------- Null - Skips the property
	// Explicit null value will skip the process of inference, applying default value, ...

	if (value === null) {
		infos.skipped = true;
		return;
	};
	infos.skipped = false;

	// ------------------------------------------------------------- Constructor

	// WARNING Same remark as in `oop` module: 'constructor' to be kept at the end
	var constructor = extractValue(propertySpec, ['ctor', 'type', 'factory', 'constructor']);

	if (constructor != null) {
		var factory = constructor.factory;
		if (factory != null) {
			infos.constructor = constructor;

			if (value !== undefined) {
				value = factory(value);
			}

			if (value == null && propertySpec.mixed) {
				try {
					infos.mixed = true;
					value = factory(input);
				} catch (e) {}
			}
		}
	}

	// ----------------------------------------------------------------- Default

	if (value === undefined) {
		var def = extractValue(propertySpec, ['default', 'def']);
		if (def != null) {
			if (prelude.isType('Function', def)) {
				// TODO be able to specify context per input
				// def = def(extractValue(input, ['context', 'scope']);
				def = def.call(context);
			}

			infos.default = true;

			value = def;

			if (factory != null && value !== undefined) {
				value = factory(value);
			}
		}
	}

	// ------------------------------------------------------------ Post-process

	var postprocess = extractValue(propertySpec, ['postprocess', 'postProcess', 'post', 'process']);
	if (postprocess != null) {
		infos.postProcessed = true;
		value = postprocess(value);
	} else {
		infos.postProcessed = false;
	}

	// ---------------------------------------------------------------- Required

	var required = extractValue(propertySpec, ['required', 'req']);
	if (required) {
		if (value == null) {
			throw {
				msg: 'Missing required value',
				property: propertySpec,
				input: input
			}
		}
	}

	// Return ------------------------------------------------------------------

	infos.value = value;
	return value;
}

// @notDocumented
function extractValueSafe(input, names, infos) {
	// ------------------------------------------------------------------- input

	if (input == null) {
		throw Error('No input given');
	}

	// ------------------------------------------------------------------- names

	if (names == null) {
		throw Error('No name given');
	}

	names = oop.types.Array.factory(names);

	// ------------------------------------------------------------------- infos

	if (infos != null && !prelude.isType('Object', infos)) {
		throw Error('Invalid given infos object');
	}

	// if (!prelude.isType('Object', infos)) {infos = {}}

	// -------------------------------------------------------------------------

	extractValue(input, names, infos);
}

/**
 * Extracts a value from the given object using the given names
 */
function extractValue(input, names, infos) {
	for (var i = 0, length = names.length; i < length; i++) {
		var name = names[i];
		var property = input[name];
		if (property !== undefined) {
			if (infos != null) {
				infos.name = name;
			}
			return property;
		}
	};
}





exports.processProperties = processProperties;
exports.inputToSpec = inputToSpec;

exports.applyProperties = applyProperties;
exports.applyProperty = applyProperty;

exports.extractProperty = extractProperty;

exports.extractValue = extractValue;

exports.propertyIds = propertyIds;
