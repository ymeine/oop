_dop_ stands for _Data Oriented Programming_. I didn't find any better name.

The thing is to work more nicely with properties of objects, and more generally with kind of types.

# File system layout

* [`README.md`](./README.md): this current file
* [`index.js`](./index.js): module entry point

# Versioning

To version: _everything_.

# Backlog

* be able to specify a set of properties with an object when properties all have only one name, with mapToArray...





# API





## Process properties

Extract values from a given value, processes them and output the result in an object. Everything is driven through given rules.

### Names

1. `processProperties`

### Arguments

1. `output`:
	* __optional__
	* type: `Any ⊢ Object`
	* An object to which the extracted properties will be put. This output is also returned by the function, and it is autmatically created for you if you don't pass any. Using this property is thus useful only to populate an already existing object.
1. `input`:
	* __required__
	* type: `Any`
	* The value from which properties are extracted. If the value is not an object, it uses a specific part of the rules to convert it to an object.
1. `rules`:
	* __required__
	* type: `Object`
	* An object describing how properties must be extracted from the input object (see below for more information)
1. `context`:
	* __optional__
	* type: `Object`
	* ___Missing description___

__WARNING:__

The way optional arguments are handled here is a bit tricky: the first and the last one are optional. This means that there can be an ambiguity, here in the case 3 arguments are passed: which one was intended to be passed?

That's why you can pass only 2 or 4 arguments, otherwise it's either ambiguous or doesn't meet the requirements. If it's 2, you passed the required arguments only, otherwise you passed everything. Remember you can pass a `void` value anyway...

### Returns

The output object, possibly created for you.

### Description

The workflow is simple:

1. It first checks if the given value is an object, if not it converts it to an object using `inputToSpec`
1. It then uses `applyProperties` to extract values from the previous object and put them into the output object

This is more like a master function combinating the two described steps for a complete workflow.

The `rules` object follows the following format:

* `inputToSpec`, `inputFactory`, `factory`: the rules for the use of `inputToSpec`
* `properties`, `props`, `schema`, `specs`, `spec`: the rules for the use of `applyProperties`
* `acceptFreeProperties`, `acceptFree`, `free`, `extensible`: a parameter forwarded to `applyProperties`

### See

* `inputToSpec`
* `applyProperties`

### Issues

#### Function name

The name is not properly chosen. It doesn't only process properties: it finds them from a given object, processes the corresponding values, and output those values into another object. Suggested names:

* `extractFromObject`
* `processInput`
* `inputToOutput`
* ...

#### Arguments order

The argument order is not suitable. First there is the issue with the optional arguments, which ideally should be put at the end of the list, the least used one the further.

Following this proposal, this would give something like: `input, rules, output, context`.

This is good as this illustrates the natural workflow: `input` → `processing` → `output`. The `context` being part of a secondary level of arguments. This context property could also be put inside the rules object, it's part of the processing specifications.





## Value to object factory

Converts any input value to an object thanks to a set of rules.

### Names

1. `inputToSpec`

### Arguments

1. `input`
	* __required__
	* type: `Any`
	* The input value to convert to an object if not already so
1. `rules`
	* __required__
	* type: `object`
	* The rules used to convert the input value

### Returns



### Description

Rules for now are simple. For a given input type, you can do one of the following:

- specify to which property (its name) of the output object the given input value will go
- specify a handler function that will get the input value and return the whole output object it builds itself

There are two default rules:

- if the given input is an object already, it is returned as is
- if nothing matches, an empty object is returned

### Example

```javascript
var rules = {
	'String': 'str',
	'Number': 'nb',
	'Boolean': function(input) {
		return {
			val: input ? 1 : 0
		}
	}
};
inputToSpec('a string', rules); // => {str: 'a string'}
inputToSpec(5, rules); // => {nb: 5}
inputToSpec(true, rules); // => {val: 1}
inputToSpec(false, rules); // => {val: 0}
```





## Apply a property

It first extracts a property using the method below. It then puts the result under a property of an output object, still regardings the given specifications.







## Extract a property

Extracts a property from an object and processes its value, thanks to a given property specifications.

### Names

1. `extractProperty`

### Arguments

1. `input`
	* __optional__
1. `propertySpec`
1. `context`
	* __optional__
	* type: `Object`
	* Very specific: it is possible to provide a function to compute a default value if the property was not found in the input. In this case, this function is called with that given `context`.
1. `infos`
	* __out__, __optional__
	* type: `Owbject`

### Description

__Property specifications__

A property has a list of names, that the user can use in the spec.

The order of names is important since it has a precedence.

The first name of the list is used by default as the name of the property in the output.

If no value was defined in the spec for the property, this is not set in the output object (no explicit undefined properties)

Workflow:

1. extracts the value from a given list of names
1. _optional_: instanciate an object using a given constructor or a factory if available, giving the previous value as input
1. _optional_: sets a default value in case the current result is strictly undefined
1. _optional_: transforms the value using a custom given function
1. _optional_: transforms the value using a custom given function


Property specifications:

```javascript
{
	names, name, keys, key, ids, id,

	ctor, type, factory, constructor,
	default, def,
	postprocess, postProcess, post, process, // An optional custom post-processing function to apply to the value
	required, req, // if defined, adds a check to verify if the final value is not null/undefined. It throws an error if so

	mixed, // tells whether the output value can be built (with constructor or factory) from the input object directly and not the value under the given property names
}
```

Infos:

```javascript
{
	originalValue, //the extracted value before any processing on it
	skipped, // `true` if the found value is null, that means that no processing is done

	// The below applies when `skipped` is false

	constructor, // if a constructor function is used to build an instance from the value, it refers to it
	factory, // if this constructor has a specific factory function to use instead, it refers to it

	postProcessed // tells whether the property has been post-processed or not. Alway true if a post-processing function was given
}
```

### Returns

### Issues

#### Mixed properties and skip with `null`

When a property is extracted from the given spec, if no suitable property value was found in this spec, the spec itself is used as the property - remember it is just used as input for a factory.

For instance, specifying:

```javascript
{
	color: {
		r,
		g,
		b
	},
	font
}
```

will work as well as:

```javascript
{
	r,
	g,
	b,
	font
}
```

directly.

HOWEVER this brings a problem when you want to actually bypass a value, set is as undefined. Take the second object and imagine `{r, g, b}` were user-specific extra properties, not the spec for the color. Or imagine there is nothing at all for the color (`{font}`). When trying to build the color property, it should fail.

The user should specify more rules to handle this properly.

For now, the user can specify `null`.

#### Constructor/factory amalgam

For now the use of the constructor is weird, and based on specific conventions which should not reside here.

Indeed, if a constructor is specifed, for something to be done it must have a property `factory`, and this is finally a simple function called as is.

Also, this behavior doesn't really take place here, it is not used to extract the property, but to build an output object.





## Extract a value

Extracts a value from an object, given a list of possible property names.

### Names

1. `extractValue`

### Arguments

1. `input`
	* __in__, __required__
	* __CONTRACT__: no existence check
	* __type__: `Any ⊢ Object`
	* The object from which the value is going to be extracted
1. `names`
	* __in__, __required__
	* __CONTRACT__: no type check
	* __type__: `Array ∋ (Any ⊢ String)`
	* The list of names under which the value can be put, __precedence is important__ of course
1. `infos`
	* __out__, __optional__
	* type: `Any ⊢ Object`
	* An object that will get information about the extracted value (see more in description)

### Description

The function iterates over the given property names to attempt getting a defined value (even `null`).

If a non-`null` `infos` object is passed, it will receive the following information when a value is found:

```javascript
{
	name // the name of the property under which the value actually was
}
```

### Returns

If a value is found, it returns it. Otherwise, it doesn't return anything.

### Example

```javascript
var input = {
	val: 'value under val'
};
var infos = {};

extractValue(input, ['value, val, prop'], infos); // => 'value under val'
// infos = {name: 'val'}
```
