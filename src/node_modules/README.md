# Helpers





## Get the type of an object

Returns the type of the object as determined by the native `toString` result.

### Names

1. `getType`

### Arguments

1. `value`
	* __in__, __optional__: `undefined`
	* type: `Any`
	* The value for which you want to get the type

### Returns

* type: `String`
* The type of `value`.

### Description

It uses the native `Object`'s prototype's method `toString` to get the value of the class of the object. Afterwards, it extracts the name of the class from teh resulting string.





## Check if a property is directly owned by an object

Tells whether a given property is owned by the given object, or not (that is either not found or found in its prototype chain).

### Names

1. `hasOwnProperty`

### Arguments

1. `object`
	* __in__, __required__
	* type: `Any ⊢ Object`
1. `property`
	* __in__, __required__
	* type: `Any ⊢ String`

### Returns

* `Boolean` type:
* `true` if the `property` is an own property of `object`, `false` otherwise.

### Description

It uses the native `Object`'s prototype's method `hasOwnProperty` underneath.

## Iterate over an object

Iterates over the properties an object, invoking the given callback with current key and value. Supports `break`.

### Names

1. `forKeyValue`

### Arguments

1. `cb`
	* __required__
	* type: `Function: [String, Any] → Boolean`
	* A function invoked at each iteration, and receiving the following parameters: `key`, `value`. If the function returns `true`, the loop is broken.
1. `object`
	* __required__
	* type: `Any ⊢ Object`
	* The object to iterate over.
1. `own`
	* __optional__: `true`
	* type: `Any ⊢ Boolean`
	* Tells whether to iterate over own properties only - if `true` - or all enumerable properties.

### Returns

* `object`, for chaining.

### Description

It uses the native `for in` loop, and the `hasOwnProperty` of the `Object`'s prototype (to avoid possible overriding). So please refer to their respective behavior to know which values to expect during the iteration.





## Import values from an object to another

Imports properties of given `source` to given `object`.

Symbol: `<<<`

### Names

1. `import`

### Arguments

1. `object`
	* __in__, __out__, __required__
	* type: `Any ⊢ Object`
	* The object in which the values will be imported
1. `source`
	* __in__, __required__
	* type: `Any ⊢ Object`
	* The object from which the values are taken
1. `importVoid`
	* __in__, __optional__: `false`
	* type: `Any ⊢ Boolean`
	* Tells whether `void` values (`null` and `undefined`) are imported or not (explicit set to the input object)
1. `own`
	* __in__, __optional__: `true`
	* type: `Boolean`
	* Tells whether to import own properties only - if `true` - or all enumerable properties.

### Returns

* `object`, for chaining.

### Description

It uses `forKeyValue` underneath to iterate over properties, passing the `own` argument.

### See

* `forKeyValue`

### Backlog

Have more configuration:

* use a blacklist or a whitelist (simple inclusion/exclusion patterns)
* ...

But keep it optimized (not easy).





## Map/Array factory

Factory for collection of objects owning one or several ids.

### Names

1. `mapArrayFactory`

### Arguments

1. `input`
	* __required__
	* type: `Array | (Any∖{Array} ⊢ Object)`
1. `property`
	* __optional__
	* type: `Any ⊢ String`
	* If given, the format of the generated objects changes.

### Returns

* type: `Array ∋ Object`

If `property` was given:

```livescript
{
	(<one of propertyIds.names>): name
	(property): value
}
```

otherwise:

```livescript
{
	(<one of propertyIds.names>): name
} <<< value
```

### Description

If you want an object to have several ids, you are forced to put these ids inside a property of this object, like this:

```javascript
[
	{
		names: ['obj1name1', 'obj1name2'],
		... // Rest
	}
	{
		names: ['obj2name1', 'obj2name2'],
		... // Rest
	}
]
```

And to have a collection of such objects, you would put it in an array.

Now imagine you have a collection of objects each containing only one id. This would be cumbersome to have to specify everytime the names property. So you would better do it like this:

```javascript
{
	obj1Name: {},
	obj2Name: {},
	...
}
```

This factory converts the latter form to the more comprehensive first one.

If you explicitely define a property name, the created objects will have only two properties:

* one for the names
* one for the defined value inside the property name you gave

like this:

```javascript
{
	names: [...],
	nested: {...}
}
```





## Assign a value on a free slot

Given an object, a value and a list of properties names, it tries to assign the value to the object under the first name not already defined in this object. Is also able to assign the value anyway in case no free slot was found.

### Names

1. `assignFree`

### Arguments

1. `output`
	* __required__
	* type: `Any ⊢ Object`
1. `value`
	* __required__
	* type: `Any`
1. `names`
	* __required__
	* type: `Array ∋ (Any ⊢ String)`
1. `override`
	* __optional__: `true`
	* type: `Any ⊢ Boolean`

### Description


