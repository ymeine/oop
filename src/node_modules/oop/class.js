var Method = require('./method').Method;
var ID = require('./id').ID;





var schemaPropertyNames = ['schema', 'input'];

function ClassSpec(input) {
	// WARNING 'constructor' always resolves to a non-null value by default, since it's set in the prototype of every JS object. So, since we still want to be able to use own properties and prorotypes properties in spec objects, we need to take care of these special cases. Here we just lookup for this name in the end. Therefore, if you hadn't set explicitely a constructor, the constructor for a raw object whould be found.

	dop.processProperties(this, input, {
		properties: [
			{names: schemaPropertyNames},
			{names: ['init', 'ctor', 'initialize', 'initialization', 'build', 'constructor'], own: true/*, default: function() {return function() {}}*/},
			{names: ['prototype', 'proto'], default: {}},

			{names: ['methods'], default: {}},
			{names: ['properties', 'props', 'attributes', 'attrs'], default: []},
			{names: ['statics'], default: {}},

			{names: ['callback', 'call']},

			{names: ['parent', 'extend', 'extends', 'superclass', 'superClass', 'super', 'ancestor', 'base']},

			{names: ['id', 'identifiant', 'key']},
			{names: ['name', 'fullname', 'fullName']},
			{names: ['displayName', 'displayname', 'display', 'debugName']},
			{names: ['description', 'desc', 'comment', 'doc', 'documentation']},

			{names: ['factories'], default: {}}
		]
	}, null);

	this.__input__ = input;
}

ClassSpec.prototype = {};


ClassSpec.prototype.createClass = function() {
	constructor.__spec__ = this;


	////////////////////////////////////////////////////////////////////////////
	// Constructor generation
	////////////////////////////////////////////////////////////////////////////

	// TODO Maybe use native utilities to define prototype explicitely, for the case of the optional new operator

	// Input schema ------------------------------------------------------------

	var schema = spec.schema;

	if (schema != null && !prelude.isType('Object', schema)) {
		throw {
			msg: 'Wrong parameter type',
			names: schemaPropertyNames,
			expected: 'Object',
			spec: spec,
			input: input
		}
	}

	// Constructor/init --------------------------------------------------------

	var init = spec.init;

	if (prelude.isType('Object', init)) {
		schema = init;
		init = null;
	}

	if (!prelude.isType('Function', init)) {
		init = function() {};
	}

	// Callable instance -------------------------------------------------------

	var callback = spec.callback;
	var callbackName;

	if (prelude.isType('Object', callback)) {
		callbackName = dop.extractValue(callback, ['alias', 'method', 'name', 'prototype']);
		callback = dop.extractValue(callback, ['def', 'definition', 'fn', 'callback', 'handler', 'exec', 'execute']);
	} else if (!prelude.isType('Function', callback)) {
		// Warning
	}

	if (callback != null) {
		// constructor.prototype = new Function;
		constructor.prototype = Object.create(new Function);
	}

	// Instance properties -----------------------------------------------------

	var properties = helpers.mapArrayFactory(spec.properties, 'descriptor');

	// Generation --------------------------------------------------------------

	// Allows calling the constructor both with and without the `new` keyword
	function constructor$() {};
	constructor$.prototype = constructor.prototype;
	function constructor() {
		// Self ----------------------------------------------------------------
		// Optional "new" & callable instance

		var self;
		// FIXME Keep Function in the prototype chain (with temp function...)
		if (callback != null) {
			self = function() {
				return callback.apply(self, arguments);
			}
			self.__proto__ = constructor.prototype;
		} else if (this instanceof constructor) {
			self = this;
		} else {
			self = new constructor$;
		}

		// Defines instance properties -----------------------------------------

		// --------------------------------------------------------- Simple form

		prelude.each(function(property) {
			prelude.each(function(name) {
				Object.defineProperty(self, name, dop.extractValue(property, ['descriptor', 'desc', 'def', 'get', 'set']));
			}, property.names);
		}, properties);

		// ---------------------------------------------------- "Optimized" form

		// for (var propertiesIndex = 0, propertiesLength = properties.length; propertiesIndex < propertiesLength; propertiesIndex++)  {
		// 	var property = properties[propertiesIndex];
		// 	var names = property.names;
		// 	for (var namesIndex = 0, namesLength = names.length; namesIndex < namesLength; namesIndex++)  {
		// 		Object.defineProperty(self, names[namesIndex], property.descriptor);
		// 	}
		// }

		// Applies actual initialization ---------------------------------------

		var args = Array.prototype.slice.call(arguments);

		if (schema != null) {
			try {
				dop.processProperties(self, args[0], schema, self);
			} catch (exception) {
				exception.class = constructor.displayName;
				throw exception;
			}
			args.shift();
		}

		init.apply(self, args);

		// Return --------------------------------------------------------------

		return self;
	}



	////////////////////////////////////////////////////////////////////////////
	// Inheritance, Prototype & statics
	////////////////////////////////////////////////////////////////////////////

	var statics = spec.statics;
	var prototype = spec.prototype;

	// Inheritance -------------------------------------------------------------

	inherit(constructor, spec.parent);

	// Prototype & Methods -----------------------------------------------------

	var methods = spec.methods;

	for (var methodName in methods) {
		prototype[methodName] = Method(methods[methodName]);
	}

	if (callbackName != null) {
		prototype[callbackName] = callback;
	}

	// Identification ----------------------------------------------------------

	helpers.import(statics, ID(spec));
	statics.description = spec.description;

	// Automatic special factory generation ------------------------------------

	statics.factory = function factory(input) {
		if (input == null) {return undefined;}
		if (input instanceof constructor) {return input;}
		return new constructor(input);
	};

	// Application & return ----------------------------------------------------

	helpers.import(constructor.prototype, prototype);
	addStatics(constructor, statics);
	addFactories(constructor, spec.factories);

	return constructor;
};



function Class(input) {
	return (new ClassSpec(input)).createClass;
}

/**
 * Adds static properties to a class, that is properties assigned to the constructor.
 *
 * @fixme Aren't statics related to prototype instead?? Check the naming.
 */
function addStatics(constructor, statics) {
	helpers.import(constructor, statics);
}

/**
 * Composite method to generate multiple factories from the given spec and add them to the given constructor.
 */
function addFactories(constructor, factoriesSpecs) {
	if (factoriesSpecs != null) {
		for (var factoryName in factoriesSpecs) {
			addFactory(constructor, factoryName, factoriesSpecs[factoryName]);
		}
	}
}



/**
 * Applies inheritance for the given constructor and parent constructor.
 *
 * Inheritance means extending (see `extend`), and importing all properties of the parent constructor to the new constructor.
 */
function inherit(constructor, parent) {
	if (parent != null) {
		helpers.import(constructor, parent);
		extend(constructor, parent);
	}
}

/**
 * Extends a constructor from a parent constructor.
 *
 * Extending means setting up the prototype chain: the prototype of the constructor is an object whose prototype itself is the one of the parent.
 *
 * It also sets some properties to access parent features, like:
 * - a link to the parent constructor: `superclass`
 */
function extend(constructor, parent) {
	constructor.superclass = parent;

	constructor.prototype = Object.create(parent.prototype, {
		constructor: {
			value: constructor,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});

	return constructor;
}







/*******************************************************************************
* Export
*******************************************************************************/

exports.Class = Class;

exports.inherit = inherit;
exports.extend = extend;

exports.addStatics = addStatics;

