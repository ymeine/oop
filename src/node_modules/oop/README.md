OOP (Object Oriented Programming) library.

See different documentations:

* [`class`](./class.md):
* [`method`](./method.md):





# Backlog

* For the method factory: instead of having multiple properties like `chainable`, `output`, etc.: have one property `output`, being a string or an object, always specifying the simple kind of output - for instance `this`, `spec`, `input` or `property`. In the latter case `property`, and additional information is required (the name of the property), so you would have to provide an object.

## Free properties

The option to accept free properties on instances built with a schema would not work properly with inheritance.

Indeed, the same spec object will be used for both class and parent(s), but each of them use it independently, without knowing what has been done.

Accepting free wraibles, this could lead to property erasing, duplication, etc.

Example:

```javascript
var classSchema = {
	properties: [
		{names: ['classNotFree', 'classAlias']}
	]
};

var parentSchema = {
	properties: [
		{names: ['parentNotFree', 'parentAlias']}
	]
};

var spec = {
	classAlias: "classAlias",
	free: "free",
	parentNotFree: "parentNotFree"
};
```

Now imagine none of the classes accepts free variables, this would result in this instance:

```javascript
{
	classNotFree: "classAlias",
	parentNotFree: "parentNotFree"
}
```

Now imagine the parent accepts free variables. It would give:
```javascript
{
	classNotFree: "classAlias",
	parentNotFree: "parentNotFree",
	classAlias: "classAlias",
	free: "free"
}
```

`classNotFree` will be kind of duplicated with `classAlias`. It the parent would have known that `classAlias` was actually used to set the final `classNotFree` property, it would not have considered it as a free variable.

Therefore take care of passing information, and of the order of processing too.

## Automatic parent constructor call

Find if in some cases we can provide an automatic call of the parent constructor.

Here are a few things to take care about:

* there must be a parent
* having a schema for the class helps determining at which step we can call the parent
* option to tell to do so

## Factory through constructor

Be able to specify a factory to be used directly through the constructor call. This requires some limits however: the thing is to ba able to distinguish a normal call and a factory call. First, it should be available only for constructors using schemas: so the constructor should take only one argulent, which is an object. Then, there are two things that can make us do the distinction: if there are more than 1 argument, or if the single argument is not an object.

## Factories forwarding with arrays (& more...)

An example will be easier here.

Imagine you have a class, which has a factory which takes two arguments.

Imagine know that each argument correspond to a type, and you would like to use their own factories too. But you can't! Indeed, you can't specify multiple arguments list like in [Scala](http://docs.scala-lang.org/style/declarations.html)!

However we could emulate this multiple arguments lists by passing arrays to arguments.

Example:

```javascript
Range.range({value: 0, inclusive: true}, {value: 5, inclusive: true});
// =>
Range.range([0, true], [5, true]);
```

This would require specifying which factory to use behind. Or we can enable setting a default factory up, and then using this one.

And also this would require detecting that having an array as input is for factory use, not construction.

However, this is close to the way `inputToSpec` works, and calling explicitely the factory on Array input would do the trick. Moreover it avoids types conflicts in this case.

This behavior for Array input in `inputToSpec` could be automatically added if the slot is free, but we still need a default factory to be defined.

__OOPS! This is false, as the `inputToSpec` returns a spec, not dierctly an instance like the factory does.__ However, this could work as factories definition does, with args and values maps. Handle `Object` inputs in addition to `String` and `Function` for `inputToSpec`, and then either take the maps directly, or a reference to a factory map (harder to do because we don't really expose these maps).

NB: In fact I see simmilarities between `inputToSpec` and factories:

* `inputToSpec` uses args and values maps in fact
* in this case, args and values maps can be build from both objects or simple string, the latter being equivalent to {args: {<string>: 0}}
* `inputToSpec` is a factory callable from the constructor function directly (they are _inline_), while others require static functions

We should try to combine the two concepts.

## Inferrence

Implement properties inferrences: specifying the name of another spec property. So this would require applying defaults and infference a level above the property extraction: we don't consider a single property but a set of them. Why `default` too? Becaise it comes after inferrence!

This would also require processing properties like a dependency manager (they are dependent indeed).

Example:

```javascript
[
	{name: 'referenced'},
	{name: 'inferred', default: 0, inferred: 'referenced'}
]
```

If `referenced` is defined, `inferred` will have its values, otherwise `0`.

Note that in this case the order of properties definition helps. If it was reversed, it would be more difficult. Because of this combination of default and inferrence. Because if we process all properties without inference, but just default, it would be fine to reprocess all of them using inferrence. But some inferrence will fail because some properties wouldn't have their default applied, because they were waiting for inferrence first. This would occur in a case like this I guess (interdependency):

```javascript
[
	{name: 'prop1', default: 1, inferred: 'prop1'},
	{name: 'prop2', default: 2, inferred: 'prop1'}
]
```

## Serialize and parse

__Serializing and parsing are two common operations made with models.__

__Add a trait: Serializable, with automatic Checksum computation__

They should be treated specifically, as top-level properties of the class definitions.

For now, you can _manually_ add them by adding to the prototype a `serialize` methods, and to statics a `parse(input)` one.

However, we could bring more support for this.

For parsing:

* checking that the input is a string, or convert it at least
* have a validator for the format

A declarative definition similar to a template would be good (with instance as context): it would be straightforward to use it for serialization, and could be used to infer a parser. Otherwise, a declarative parser definition could be considered.

## FIXME

* How to change the real display name of a function? Note that the `name` property of a function is already natively taken.
