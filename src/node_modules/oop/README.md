OOP (Object Oriented Programming) library.

# TODO

* For the method factory: instead of having multiple properties like `chainable`, `output`, etc.: have one property `output`, being a string or an object, always specifying the simple kind of output - for instance `this`, `spec`, `input` or `property`. In the latter case `property`, and additional information is required (the name of the property), so you would have to provide an object.

## Free properties

The option to accept free properties on instances built with a schema would not work properly with inheritance.

Indeed, the same spec object will be used for both class and parent(s), but each of them use it independently, without knowing what has been done.

Accepting free wraibles, this could lead to property erasing, duplication, etc.

Example:

```javascript
var classSchema = {
	properties: [
		{names: ['classNotFree', 'classAlias']}
	]
};

var parentSchema = {
	properties: [
		{names: ['parentNotFree', 'parentAlias']}
	]
};

var spec = {
	classAlias: "classAlias",
	free: "free",
	parentNotFree: "parentNotFree"
};
```

Now imagine none of the classes accepts free variables, this would result in this instance:

```javascript
{
	classNotFree: "classAlias",
	parentNotFree: "parentNotFree"
}
```

Now imagine the parent accepts free variables. It would give:
```javascript
{
	classNotFree: "classAlias",
	parentNotFree: "parentNotFree",
	classAlias: "classAlias",
	free: "free"
}
```

`classNotFree` will be kind of duplicated with `classAlias`. It the parent would have known that `classAlias` was actually used to set the final `classNotFree` property, it would not have considered it as a free variable.

Therefore take care of passing information, and of the order of processing too.

## Automatic parent constructor call

Find if in some cases we can provide an automatic call of the parent constructor.

Here are a few things to take care about:

* there must be a parent
* having a schema for the class helps determining at which step we can call the parent
* option to tell to do so

## Factory through constructor

Be able to specify a factory to be used directly through the constructor call. This requires some limits however: the thing is to ba able to distinguish a normal call and a factory call. First, it should be available only for constructors using schemas: so the constructor should take only one argulent, which is an object. Then, there are two things that can make us do the distinction: if there are more than 1 argument, or if the single argument is not an object.

## Factories forwarding with arrays (& more...)

An example wil be easier here.

Imagine you have a class, which has a factory which takes two arguments.

Imagine know that each argument correspond to a type, and you would like to use their own factories too. But you can't! Indeed, you can't specify multiple arguments list like in [Scala](http://docs.scala-lang.org/style/declarations.html)!

However we could emulate this multiple arguments lists by passing arrays to arguments.

Example:

```javascript
Range.range({value: 0, inclusive: true}, {value: 5, inclusive: true});
// =>
Range.range([0, true], [5, true]);
```

This would require specifying which factory to use behind. Or we can enable setting a default factory up, and then using this one.

And also this would require detecting that having an array as input is for factory use, not construction.

However, this is close to the way `inputToSpec` works, and calling explicitely the factory on Array input would do the trick. Moreover it avoids types conflicts in this case.

This behavior for Array input in `inputToSpec` could be automatically added if the slot is free, but we still need a default factory to be defined.

__OOPS! This is false, as the `inputToSpec` returns a spec, not dierctly an instance like the factory does.__ However, this could work as factories definition does, with args and values maps. Handle `Object` inputs in addition to `String` and `Function` for `inputToSpec`, and then either take the maps directly, or a reference to a factory map (harder to do because we don't really expose these maps).

NB: In fact I see simmilarities between `inputToSpec` and factories:

* `inputToSpec` uses args and values maps in fact
* in this case, args and values maps can be build from both objects or simple string, the latter being equivalent to {args: {<string>: 0}}
* `inputToSpec` is a factory callable from the constructor function directly (they are _inline_), while others require static functions

We should try to combine the two concepts.

## Consistency

Change the name `methodFactory` to `Method`. Indeed, these are classes, representing OOP concepts: `Class`, `Method`, `Attribute`, `Prototype` (?), ...

## Inferrence

Implement properties inferrences: specifying the name of another spec property. So this would require applying defaults and infference a level above the property extraction: we don't consider a single property but a set of them. Why `default` too? Becaise it comes after inferrence!

This would also require processing properties like a dependency manager (they are dependent indeed).

Example:

```javascript
[
	{name: 'referenced'},
	{name: 'inferred', default: 0, inferred: 'referenced'}
]
```

If `referenced` is defined, `inferred` will have its values, otherwise `0`.

Note that in this case the order of properties definition helps. If it was reversed, it would be more difficult. Because of this combination of default and inferrence. Because if we process all properties without inference, but just default, it would be fine to reprocess all of them using inferrence. But some inferrence will fail because some properties wouldn't have their default applied, because they were waiting for inferrence first. This would occur in a case like this I guess (interdependency):

```javascript
[
	{name: 'prop1', default: 1, inferred: 'prop1'},
	{name: 'prop2', default: 2, inferred: 'prop1'}
]
```

## Serialize and parse

__Serializing and parsing are two common operations made with models.__

They should be treated specifically, as top-level properties of the class definitions.

For now, you can _manually_ add them by adding to the prototype a `serialize` methods, and to statics a `parse(input)` one.

However, we could bring more support for this.

For parsing:

* checking that the input is a string, or convert it at least
* have a validator for the format

A declarative definition similar to a template would be good (with instance as context): it would be straightforward to use it for serialization, and could be used to infer a parser. Otherwise, a declarative parser definition could be considered.

# Class

Creates a class from the properties you gave.

Returns a constructor function generated from the given specifications.

## FIXME

* How to change the real display name of the function? And the `name` property of a function is already natively taken.

## Constructor, methods, properties, statics, factories, ...

The title of this section enumerates a bunch of usual properties we find in OOP. Here they are described.

### Constructor

Here we are talking about the constructor specification, given as input, not the actual returned constructor which is generated by this utility.

The construtor is in charge to initialize an instance of the class.

That's why sometimes people are calling it the `init` function, or something like that.

Here you can either pass a function to be called to initialize the instance, or an object specification in case of a pure object constructor without specific processing.

In the latter case, the generated constructor will not call any initialization function but use the `processProperties` utility applied on the created instance.

### Properties

Instance properties can be defined thourgh the `Object.defineProperty` method, instead of basic assignment in the constructor/init function.

Here you can specify a list of `properties` to define at construction.

For each property you can define a list of names, and one descriptor (the same to be used with the native property definition function).

### Factories



## Generated constructor

## Callable instances

## Inheritance

Simple inheritance is implemented, just provide a valid constructor function in case you want to inherit it, under the property: `parent`.

In this case, the classical JavaScript prototype inheritance is applied. Also, properties from the parent constructor are copied into the constructor of this class.

## Special factory

A special factory is always generated, under the name `factory` (assigned to the constructor).

It is special in that it can be used to avoid unecessary object constructions: in case the given input is already an instance of the class, the factory returns it directly, otherwise it forwards the single input argument to the constructor and returns the created instance.

So if you want to make a copy of an object using an already existing instance, DON'T use this special factory!

## Identification

You can set some identifications properties for the class, like:

- `displayName`: display name, supported by some engine for debugging
- `name`: the name of your class
- `id`: an id for easy programmatic reference
- `description`: a description of the class, like its documentation for instance

Display name, name and ids can be inferred from each other (depending on which ones are specified).

# Factory

Creates a factory from the given spec for the given constructor.

Classes, and thus constructors, generated by this module use specification objects as input. Sometimes other primitive values can be given as input, but they will be converted to object specifications in functions of their types. However, you can always give only ONE value.

A factory function is a way to use the positional arguments of the function instead of properties of an object.

Therefore the usual schema to create a factory is to map positional arguments to the spec object properties, and this function does that for you.

Note that factories also often use default values, so you can also directly map values to the spec object properties.

Example of mapping specification to create the factory:

```javascript
{
args: {targetProperty1: 0},
values: {targetProperty0: "default"}
}
```

This would produce an object specification (used for the constructor input) like this:

```javascript
{
targetProperty0: "default",
targetProperty1: arguments[0] // value of the first argument passed to the factory
}
```

# Method

`methodFactory`

Factory for method creation.

You can either specify a method with a function, in which case it is immediately returned, or with specifications.

To generate a method with specifications, you can provide information about:

- optional but advised: the schema of the input argument, like if you would process it with `processProperties`
- mandatory: the actual function, receiving either the result of the schema processing if provided, or all the arguments forwarded
- optional: if you want to return directly a property from the spec generated from the schema, specify its name here. Makes sense only if a schema was provided
