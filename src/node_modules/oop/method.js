var prelude = require('prelude-ls');

var dop = require('dop');



function Method(methodSpec) {
	// Input factory -----------------------------------------------------------

	if (prelude.isType('Function', methodSpec)) {
		methodSpec = {
			process: methodSpec
		};
	}

	// Processing --------------------------------------------------------------

	dop.processProperties(method, methodSpec, {
		properties: [
			{names: ['input', 'in', 'arg', 'argument', 'schema', 'spec']},
			{names: ['process', 'exec', 'execute', 'run', 'fn', 'handler']},
			{names: ['chain', 'chainable']},
			{names: ['output', 'out', 'return', 'returns']},
			{names: ['cache', 'memoize']}
		]
	}, null);

	method._cache = {};

	function method(input) {
		// Early termination ------------------------------------------- caching

		if (method.cache === true) {
			var result = method._cache[input];
			if (result !== undefined) {
				return result;
			}
		}

		// ----------------------------------------------- arguments computation

		var args;
		if (method.input != null) {
			args = Array.prototype.slice.call(arguments);
			var spec = dop.processProperties(null, input, method.input, this);
			args[0] = spec;
		} else {
			args = arguments;
		}

		//----------------------------------------------------------------- call

		var result = method.process.apply(this, args);

		// ------------------------------------------------------------- caching

		if (method.cache === true) {
			method._cache[input] = result;
		}

		// Returns -------------------------------------------------------------

		// ------------------------------------------------------------ chaining

		if (method.chain != null) {
			if (method.chain === true) {return this;}
			if (method.chain !== false) {
				// We take original arguments, so no processed spec an be returned
				return arguments[method.chain];
			}
		}

		// ----------------------------------------------- Special spec chaining

		if (method.output != null && spec != null) {return spec[method.output];}

		// ------------------------------------------------------- simple result

		return result;
	}

	// Return ------------------------------------------------------------------

	return method;
}

/**
 * the first function can have any number of arguments, while the others only have one. There could be an option to be able to change that, and for instance treat arrays result value as a list of arguments for the next function. This means of course having specific function agreeing on the format of their outputs, instead of agreeing on the one of their inputs.
 */
function compose(functions, context) {
	if (context == null) {context = this}

	return function() {
		var result;
		var args = arguments;

		prelude.each(function(fn) {
			result = fn.apply(context, args);
			args = [result];
		}, functions);

		return result;
	}
}

function negate(fn, context) {
	if (context == null) {context = this}

	return function() {
		return !(fn.apply(context, arguments));
	}
}

function partialize(fn, arguments, context) {

}



/*******************************************************************************
* Export
*******************************************************************************/

exports.Method = Method;

exports.compose = compose;
exports.negate = negate;
exports.partialize = partialize;
